<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>The Kaleidoscope Language（万花筒语言）——LLVM学习 | 二十四的温馨小窝</title><meta name="keywords" content="LLVM学习记录"><meta name="author" content="K1bo24"><meta name="copyright" content="K1bo24"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习Kaleidoscope:Kaleidoscope Introduction and the Lexer（万花筒语言的简介和词法）">
<meta property="og:type" content="article">
<meta property="og:title" content="The Kaleidoscope Language（万花筒语言）——LLVM学习">
<meta property="og:url" content="http://example.com/2022/01/08/The%20Kaleidoscope%20Language/index.html">
<meta property="og:site_name" content="二十四的温馨小窝">
<meta property="og:description" content="学习Kaleidoscope:Kaleidoscope Introduction and the Lexer（万花筒语言的简介和词法）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720210401170113-gigapixel-scale-2_00x.jpg">
<meta property="article:published_time" content="2022-01-08T11:48:12.519Z">
<meta property="article:modified_time" content="2022-01-08T11:47:50.554Z">
<meta property="article:author" content="K1bo24">
<meta property="article:tag" content="LLVM学习记录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720210401170113-gigapixel-scale-2_00x.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/01/08/The%20Kaleidoscope%20Language/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'The Kaleidoscope Language（万花筒语言）——LLVM学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-08 19:47:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="二十四的温馨小窝" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720210401170113-gigapixel-scale-2_00x.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">二十四的温馨小窝</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">The Kaleidoscope Language（万花筒语言）——LLVM学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-08T11:48:12.519Z" title="发表于 2022-01-08 19:48:12">2022-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-08T11:47:50.554Z" title="更新于 2022-01-08 19:47:50">2022-01-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LLVM/">LLVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="The Kaleidoscope Language（万花筒语言）——LLVM学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>学习<strong>Kaleidoscope:Kaleidoscope Introduction and the Lexer（万花筒语言的简介和词法）</strong></p>
<span id="more"></span>
<h3 id="万花筒语言简介和词法">万花筒语言简介和词法</h3>
<h4 id="万花筒语言">万花筒语言</h4>
<p>万花筒语言中唯一的数据类型是<strong>64位浮点类型（也就是C语言中的double）</strong>，并且该语言不需要类型声明，例如下面的计算<strong>斐波那契数列</strong>的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 计算第x个斐波那契数.</span><br><span class="line"><span class="meta"># def：定义</span></span><br><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x &lt; 3 then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line">    fib(x-1)+fib(x-2)</span><br><span class="line"></span><br><span class="line"># 这个表达式会输出第<span class="number">40</span>个斐波那契数</span><br><span class="line">fib(<span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>允许Kaleidoscope调用标准库函数（LLVM JIT使这完全无关紧要）。这意味着您可以在使用之前使用’extern’关键字来定义函数（这对于相互递归函数也很有用）。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">sin</span><span class="params">(arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">cos</span><span class="params">(arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">atan2</span><span class="params">(arg1 arg2)</span></span>;</span><br><span class="line"><span class="built_in">atan2</span>(<span class="built_in">sin</span>(<span class="number">.4</span>), <span class="built_in">cos</span>(<span class="number">42</span>))</span><br></pre></td></tr></table></figure>
<h4 id="词法分析器-gettok">词法分析器 / gettok</h4>
<p>使用词法分析器分析万花筒语言</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果token是未知字符，词法分析器返回对应的0~255，否则词法分析器将返回其中一个已知的token</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">  tok_eof = <span class="number">-1</span>,</span><br><span class="line">  <span class="comment">// commands</span></span><br><span class="line">  tok_def = <span class="number">-2</span>,</span><br><span class="line">  tok_extern = <span class="number">-3</span>,</span><br><span class="line">  <span class="comment">// primary</span></span><br><span class="line">  tok_identifier = <span class="number">-4</span>,</span><br><span class="line">  tok_number = <span class="number">-5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> IdentifierStr; <span class="comment">// Filled in if tok_identifier</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> NumVal;             <span class="comment">// Filled in if tok_number</span></span><br></pre></td></tr></table></figure>
<p>词法分析器返回的每个标记将会是<strong>token的枚举值之一</strong>，或者它会是一个“未知”的字符，比如“+”，那么它将会作为<strong>ASCII值返回</strong>。</p>
<p>如果当前token是<strong>标识符</strong>，则string类型的全局变量<strong>IdentifierStr将会保存标识符的名称</strong>。</p>
<p>如果当前token是<strong>数字（如3.14）</strong>，则<strong>NumVal保存其值</strong>。（为了简单起见，这里使用了全局变量，实际上这并不是最佳选择）。</p>
<p>词法分析器的实际实现是一个名为gettok的函数，gettok函数。</p>
<p>gettok函数通过调用C语言的getchar函数从标准输入<strong>每次读取一个字符</strong>，在识别他们时会“吃掉”他们，并在<strong>LastChar中保存最后一个未处理的字符</strong>。</p>
<p>gettok函数要做的第一件事就是<strong>忽略token之间的空格</strong>，通过下面的循环实现这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///gettok——从标准输入返回下一个token</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettok</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    static int LastChar=&#x27;&#x27;; //static类型，只初始化一次</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跳过空白符</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isspace</span>(LastChar))</span><br><span class="line">        LastChar=getchar();</span><br></pre></td></tr></table></figure>
<p>接下来gettok需要做的是识别标识符和特定的关键字比如“def”，通过下面的循环实现这一点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">isalpha</span>(LastChar)) <span class="comment">//isalpha函数用于判断是不是字母(包含大小写)</span></span><br><span class="line">&#123;</span><br><span class="line">    IdentifierStr=LastChar;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isalnum</span>((LastChar=getchar()))) <span class="comment">//isalnum函数用于判断是数字或字母</span></span><br><span class="line">        IdentifierStr+=LastChar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测到关键字</span></span><br><span class="line">    <span class="keyword">if</span>(IdentifierStr == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> tok_def;</span><br><span class="line">    <span class="keyword">if</span>(IdentifierStr == <span class="string">&quot;extern&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> tok_extern;</span><br><span class="line">    <span class="comment">//其他关键字</span></span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来处理数字相关：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">isdigit</span>(LastChar) || LastChar==<span class="string">&#x27;.&#x27;</span>) <span class="comment">//isdigit函数用于判断是不是十进制数字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用于存放数字串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> NumStr;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        NumStr += LastChar;</span><br><span class="line">        LastChar = getChar();</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">isdigit</span>(LastChar) || LastChar==<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    Numval = strtod(NumStr.c_str(),<span class="number">0</span>); <span class="comment">//将string转化为double</span></span><br><span class="line">    <span class="keyword">return</span> tok_number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是处理输入的非常简单的代码。从输入读取数值时，我们可以使用C语言的strtod函数将string类型转化为double类型，若要提高健壮性，则要进行数字检查（如1.23.456.7并不能和1.23一样处理），接下来是处理注释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(LastChar==<span class="string">&#x27;#&#x27;</span>)  <span class="comment">//出现这个表示之后的一整行都是注释</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            LastChar=getchar();</span><br><span class="line">        &#125;<span class="keyword">while</span>(LastChar!=EOF &amp;&amp; LastChar!=<span class="string">&#x27;\n&#x27;</span> &amp;&amp; LastChar!=<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//通过一路跳到行尾来处理注释，然后返回下一个token</span></span><br><span class="line">        <span class="keyword">if</span>(LastChar!=EOF)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> gettok();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(LastChar==EOF)  <span class="comment">//到达文件的末尾</span></span><br><span class="line">        <span class="keyword">return</span> tok_eof;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则，就返回这个字符的ASCII</span></span><br><span class="line">    <span class="keyword">int</span> ThisChar=LastChar;</span><br><span class="line">    LastChar=getChar();</span><br><span class="line">    <span class="keyword">return</span> ThisChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，就已经有了万花筒语言的完整词法分析器。</p>
<h4 id="抽象语法树（AST）">抽象语法树（AST）</h4>
<h5 id="表达式">表达式</h5>
<h6 id="表达式-ExprAST-NumberExprAST">表达式 / ExprAST / NumberExprAST</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有表达式节点的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~ExprAST()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字抽象语法树——用于数字文字“1.0”的表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span>:</span> <span class="keyword">public</span> ExprAST</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> Val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumberExprAST(<span class="keyword">double</span> val) :val(Val)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码显示了<strong>ExprAST基类</strong>的定义以及<strong>用于数字文本的一个子类</strong>的定义。</p>
<p>此代码的重要注意事项是NumberExprAST子类将数字文本的数值<strong>捕获为实例变量</strong>，便于编译器后续能够知道存储的数值是什么。</p>
<h6 id="变量表达式AST-VariableExprAST">变量表达式AST / VariableExprAST</h6>
<p>现在仅创建AST，因此现在没有写访问的方法（函数），以下是在万花筒语言的基本形式中使用的其他表达式的AST节点的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量表达式抽象语法树——用于引用一个变量的表达式类，如“a”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableExprAST</span>:</span> <span class="keyword">public</span> ExprAST</span><br><span class="line">&#123;<span class="comment">//用于存储变量名</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用const保证传入的Name不被修改</span></span><br><span class="line">    VariableExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name): Name(Name)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="二元运算符表达式AST-BinaryExprAST">二元运算符表达式AST / BinaryExprAST</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二元运算符表达式抽象语法树——用于一个二元运算符的表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExprAST</span>:</span> <span class="keyword">public</span> ExprAST</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> Op;</span><br><span class="line">    <span class="comment">//智能指针——一个仅能移动的类型，也可以自动释放内存。使用std::move函数将指针的所有权从一个unique_ptr转移到另一个unique_ptr</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS,RHS;  <span class="comment">//左被运算符，右被运算符</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//将输入的Op给类内Op，将传入的智能指针转移到类内的智能指针</span></span><br><span class="line">    BinaryExprAST(<span class="keyword">char</span> op,<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS,<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; RHS): Op(op),LHS(<span class="built_in">std</span>::move(LHS)),RHS(<span class="built_in">std</span>::move(RHS))&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="函数调用表达式AST-CallExprAST">函数调用表达式AST / CallExprAST</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数调用表达式抽象语法树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallExprAST</span>:</span> <span class="keyword">public</span> ExprAST</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> Callee;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args; <span class="comment">//用于存储函数参数列表的数组</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CallExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Callee,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args): Callee(Callee),Args(<span class="built_in">std</span>::move(Args))&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>变量捕获变量名称，二元运算符捕获它们的操作符（如“+”），函数调用捕获函数名称和它的参数表达式的列表。这里没有讨论二元运算符的优先级和词法结构。</strong></p>
<h6 id="函数声明AST-PrototypeAST">函数声明AST / PrototypeAST</h6>
<p>对于我们的基本语言，以上这些就是我们定义的所有表达式的节点。<code>因为它没有条件控制流程，所以它不是图灵完备的。</code>接下来需要解决的是<strong>讨论函数接口的方法</strong>以及<strong>讨论函数本身的方法</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类表示函数的声明，捕获函数名及其参数列表（因此隐式表示函数接受的参数）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeAST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PrototypeAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args): Name(name),Args(<span class="built_in">std</span>::move(Args))&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="函数定义AST-FunctionAST">函数定义AST / FunctionAST</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类用于表示函数定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionAST</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto; <span class="comment">//上方类的智能指针，存储函数【声明】</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body; <span class="comment">//存储函数体</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    FunctionAST(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Prototype&gt; Proto,<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body): Proto(<span class="built_in">std</span>::move(Proto)),Body(<span class="built_in">std</span>::move(Body))&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="解析基础">解析基础</h5>
<p>现在需要构建一个AST，需要定义<strong>解析器</strong>代码来构建它。这里的想法是我们要解析类似“x+y”（由<strong>词法分析器</strong>返回<strong>三个token</strong>）到AST中，可以通过这样的调用生成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> LHS = llvm::make_unique&lt;VariableExprAST&gt;(<span class="string">&quot;x&quot;</span>);  <span class="comment">//使用智能指针创建节点</span></span><br><span class="line"><span class="keyword">auto</span> RHS = llvm::make_unique&lt;VariableExprAST&gt;(<span class="string">&quot;y&quot;</span>);  <span class="comment">//使用智能指针创建节点</span></span><br><span class="line"><span class="keyword">auto</span> Result = <span class="built_in">std</span>::make_unique&lt;BinaryExprAST&gt;(<span class="string">&quot;+&quot;</span>,<span class="built_in">std</span>::move(LHS),<span class="built_in">std</span>::move(RHS));  <span class="comment">//使用智能指针创建节点</span></span><br></pre></td></tr></table></figure>
<p>首先需要定义一些基本的帮助程序：</p>
<h6 id="缓冲区-getNextToken">缓冲区 / getNextToken</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供一个简单的token缓冲区，CurTok是解析器正在查看的当前token</span></span><br><span class="line"><span class="comment">//getNextToken是从词法分析器读取下一个token，并用其来更新CurTok</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> CurTok;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextToken</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CurTok=gettok(); <span class="comment">//在上方【词法分析器】章节中定义的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就在词法分析器周围实现了一个简单的token缓冲区，这允许我们在词法分析器返回时<strong>提前查看一个token</strong>，我们的<strong>解析器</strong>中的每个函数都假定<strong>CurTok是需要解析的当前标记</strong>。</p>
<h6 id="错误帮助-LogError">错误帮助 / LogError</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///这是用于错误处理的帮助函数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; <span class="title">LogError</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*Str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fprint(<span class="built_in">stderr</span>,<span class="string">&quot;LogError: %s\n&quot;</span>, Str); <span class="comment">//stderr：标准错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数“原型”</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; <span class="title">LogErrorP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogError(Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LogError程序是我们的解析器用来处理错误的简单的辅助程序。</p>
<h5 id="基本表达式的解析">基本表达式的解析</h5>
<h6 id="数字表达式的解析-ParseNumberExpr">数字表达式的解析 / ParseNumberExpr</h6>
<p>接下来从<strong>数字文本</strong>开始，对于数字文本，有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//numberexpr::=number</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; <span class="title">ParseNumberExpr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//可见上方对数字语法树的描述</span></span><br><span class="line">    <span class="keyword">auto</span> Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal); <span class="comment">//使用智能指针创建节点</span></span><br><span class="line">    getNextToken();  <span class="comment">//消耗掉数字</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::move(Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序希望在当前token是tok_number时被调用，它会获取当前数字的值，创建NumberExprAST子类的节点，然后将<strong>词法分析器前进到下一个token</strong>，最后返回。</p>
<h6 id="括号运算符的解析-ParseParenExpr">括号运算符的解析 / ParseParenExpr</h6>
<p>对于<strong>括号运算符</strong>，有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// parenexpr ::= &#x27;(&#x27; expression &#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; <span class="title">ParseParenExpr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNextToken();  <span class="comment">//“吃掉”左括号“（”</span></span><br><span class="line">    <span class="keyword">auto</span> V = ParseExpression(); <span class="comment">//解析表达式</span></span><br><span class="line">    <span class="keyword">if</span>(!V)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//如果解析表达式为空</span></span><br><span class="line">    <span class="keyword">if</span>(CurTok != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> LogError(<span class="string">&quot;expected &#x27;)&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getNextToken();  <span class="comment">//“吃掉”右括号“）”</span></span><br><span class="line">    <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数通过<strong>递归使用</strong>PareExpression来完成【详见下方的<strong>解析表达式</strong>】。</p>
<p>括号不会导致AST节点本身的构造，括号最重要的作用是<strong>引导解析器并提供分组</strong>，解析器构造AST后，不需要括号。</p>
<h6 id="标识符表达式的解析-ParseIdentifierExpr">标识符表达式的解析 / ParseIdentifierExpr</h6>
<p>下面是用于处理<strong>变量引用</strong>和<strong>函数调用</strong>的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// identifierexpr</span></span><br><span class="line"><span class="comment">/// 	::= identifier</span></span><br><span class="line"><span class="comment">/// 	::= identifier &#x27;(&#x27; expression* &#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; <span class="title">PraseIdentifierExpr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> IdName = IdentifierStr;</span><br><span class="line">    </span><br><span class="line">    getNextToken();  <span class="comment">//“吃掉”标识符</span></span><br><span class="line">    <span class="keyword">if</span>(CurTok != <span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">        <span class="keyword">return</span> llvm::make_unique&lt;VariableExprAST&gt;(IdName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数调用</span></span><br><span class="line">    getNextToken();  <span class="comment">//吃掉左括号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line">    <span class="keyword">if</span>(CurTok!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">auto</span> Arg = ParseExpression())</span><br><span class="line">                Args.push_back(<span class="built_in">std</span>::move(Arg));<span class="comment">//依次将解析表达式加入数组中</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(CurTok==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(CurTok!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> LogError(<span class="string">&quot;Expected &#x27;)&#x27; or &#x27;,&#x27; in argument list&quot;</span>);</span><br><span class="line">            getNextToken();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//吃掉右括号</span></span><br><span class="line">    getNextToken();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;CallExprAST&gt;(IdName,<span class="built_in">std</span>::move(Args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前的token是tok_identifier，则希望调用这个函数。</p>
<h6 id="主表达式的解析-ParsePrimary">主表达式的解析 / ParsePrimary</h6>
<p>现在已经有了所有简答表达式的解析逻辑，可以定义一个辅助函数将它们组合成一个入口，称这类表达式为主要表达式。为了解析任意的<strong>主表达式</strong>，则需要确定它是什么类型的表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///  ::= identifier</span></span><br><span class="line"><span class="comment">///  ::= numberexpr</span></span><br><span class="line"><span class="comment">///  ::= parenexpr</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(CurTok)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> LogError(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> tok_identifier:</span><br><span class="line">            <span class="keyword">return</span> ParseIdentifierExpr();</span><br><span class="line">        <span class="keyword">case</span> tok_number:</span><br><span class="line">            <span class="keyword">return</span> ParseNumberExpr();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> ParseParenExpr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这段程序就能通过预测来确定正在检查哪种表达式，然后使用函数调用对其进行解析。</p>
<h5 id="二元表达式的解析">二元表达式的解析</h5>
<p>二进制表达式很难解析，因为它们通常是模糊的。例如，当给定字符串“x + y <em>z”时，解析器可以选择将其解析为“（x + y）</em> z”或“x +（y *z）”。对于数学中的常见定义，我们期望后面的解析，因为<strong>乘法具有比加法更高的优先级</strong>。</p>
<h6 id="优先级表-GetTokPrecedence">优先级表 / GetTokPrecedence</h6>
<p>有很多方法可以解决这个问题，但优雅而有效的方法是使用Operator-Precedence Parsing。此解析技术使用二元运算符的优先级来指导递归。首先，我们需要一个<strong>优先级表</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///它保留已定义的每个二元运算符的优先级</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; BinopPrecedence;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取挂起的二元运算符token的优先级</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isascii(CurTok))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//要确保它是一个已经声明的二元运算符</span></span><br><span class="line">    <span class="keyword">int</span> TokPrec = BinopPrecedence[CurTok];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(TokPrec&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TokPrece;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//规定标准的二元运算符</span></span><br><span class="line">    <span class="comment">//最低的优先级是1</span></span><br><span class="line">    BinopPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">    BinopPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">    BinopPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">    BinopPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>;  <span class="comment">//最高优先级</span></span><br><span class="line">   </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前对于万花筒的基本形式，只写了四个二元运算符。使用GetTokPrecedence函数返回当前token的优先级，如果token不是二元运算符，则返回-1。使用map可以随意添加二元运算符。</p>
<p>通过上面定义的程序，现在可以开始解析二元表达式，因为括号是<strong>主表达式</strong>，所以二元表达式解析器不需要担心嵌套的子表达式。</p>
<h6 id="解析表达式-ParseExpression">解析表达式 / ParseExpression</h6>
<p>运算符优先级解析的基本思想是将具有可能不明确的二元运算符的表达式分解为多个部分。</p>
<p>例如，考虑表达式“<strong>a + b +（c + d） *e* f + g</strong>”。</p>
<p>它将首先解析主要的主要表达式“a”，然后它将看到对**[+，b]    [+，（c + d）]    [*，e]   [*，f]和  [+，g]** 。请注意，因为括号是主表达式，所以二进制表达式解析器根本不需要担心嵌套的子表达式，如（c + d）。</p>
<p>首先，表达式是一个主表达式，可能后面跟一系列【binop，primaryepxr】对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">/// 	::= primary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; <span class="title">ParseExpression</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> LHS = ParsePrimary(); <span class="comment">//分析二元表达式左部的主表达式，见上方【主表达式的解析】</span></span><br><span class="line">    <span class="keyword">if</span>(!LHS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ParseBinOpRHS(<span class="number">0</span>,<span class="built_in">std</span>::move(LHS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ParseBinOpRHS是解析对序列的函数，它需要一个<strong>优先级</strong>和一个<strong>指向目前已解析的部分的表达式的指针</strong>。</p>
<h6 id="解析二元表达式的右部-ParseBinOpRHS">解析二元表达式的右部 / ParseBinOpRHS</h6>
<p>传入的优先级的值表示<strong>允许该函数吃掉的最小的运算符优先级</strong>。例如，如果当前的对是【+，x】，并且ParseBinOpRHS传入的是<strong>40的优先级</strong>，则该函数不会吃掉任何token（因为加号的优先级<strong>仅为20</strong>），考虑到这一点，则有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">/// 	::= (&#x27;+&#x27; primary)*</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; <span class="title">ParseBinOpRHS</span><span class="params">(<span class="keyword">int</span> ExprPrec,<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果这是一个二元运算符，就需要它的优先级</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> TokPrec = GetTokPrecedence();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这个（下一个）运算符的优先级大于当前的运算符，就消耗掉它，否则就结束程序</span></span><br><span class="line">        <span class="keyword">if</span>(TokPrec &lt; ExprPrec)</span><br><span class="line">            <span class="keyword">return</span> LHS;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在我们知道这是一个二元运算符了</span></span><br><span class="line">        <span class="keyword">int</span> BinOp = CurTok;</span><br><span class="line">        getNextToken();  <span class="comment">//吃掉这个运算符,将其包含在表达式中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//分析二元运算符之后的主表达式</span></span><br><span class="line">        <span class="keyword">auto</span> RHS = ParsePrimary();</span><br><span class="line">        <span class="keyword">if</span>(!RHS)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>此代码获取当前token的优先级，并检查它是否过低，因为我们将无效的<strong>即除了运算符以外的字符</strong>的优先级定义为-1，所以此检查知道标记流消耗掉二元运算符时，就停止<strong>对</strong>流，</p>
<p>这样一来，此程序吃掉并记住二元运算符，然后解析其右部的主表达式。</p>
<p>现在我们解析了<strong>运算符左部的表达式</strong>和<strong>一对RHS序列</strong>，接下来必须决定表达式关联的方式。特别是可能有“**（a+b） binop unparsed **” 或者“<strong>a+（b binop unparsed）</strong> ” 两种形式，为了确定这一点，我们预观测binop并确定其优先级，并将其与BinOp（当前是指a后面的加号）的优先级进行比较，<strong>显然binop是“+”，优先级小于等于BinOp，故选择第一种形式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果预测运算符的优先级小于等于当前运算符，就把当前处理的对的右部与左侧关联，即 (a+b) binop unparsed</span></span><br><span class="line"><span class="comment">// 如果预测运算符的优先级大于当前运算符，就把当前处理的对的右部与右侧关联，即 a+(b binop unparsed)</span></span><br><span class="line"><span class="keyword">int</span> NextPrec= GetTokPrecedence();</span><br><span class="line"><span class="keyword">if</span>(TokPrec &lt; NextPrec)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>考虑表达式“<strong>a + b +（c + d） *e* f + g</strong>”：</p>
<p>它将首先解析主要的主要表达式“a”，然后它将看到对**[+，b]    [+，（c + d）]    [*，e]   [*，f]和  [+，g]** 。</p>
</li>
</ul>
<p>如果binop在RHS右边的优先级<strong>小于等于</strong>当前运算符的优先级，那么就是**（a+b）binop**。当前运算符为**+<strong>，下一个运算符为</strong>+<strong>，他们有相同的优先级，在这种情况下，将为</strong>a+b**创建AST节点，然后继续解析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">			...省略<span class="keyword">if</span>体...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//合并 LHS/RHS</span></span><br><span class="line">	LHS = llvm::make_unique&lt;Binary&lt;ExprAST&gt;(BinOp,<span class="built_in">std</span>::move(LHS),<span class="built_in">std</span>::move(RHS));</span><br><span class="line"></span><br><span class="line">	 	&#125; <span class="comment">//跳转回顶部，继续执行while循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，会把<strong>a+b+<strong>变成</strong>(a+b)<strong>进行下一次的循环，其中</strong>第二个+<strong>作为当前token，将上面代码消耗，存储并解析</strong>(c+d)<strong>作为主表达式，就使得当前的</strong>对</strong>变成了**[+,(c+d)]<strong>，然后它将使用</strong>下一个***作为主要右侧的二元运算符来进行上方if条件的判断，这种情况下，***<strong>的优先级大于</strong>+**的优先级，因此执行if体中的代码。</p>
<p>接下来的关键问题就是：如何在if里完全解析右部。特别是，要构建正确的AST，它需要将所有的**(c+d)*e*f**作为RHS表达式变量，执行此操作的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果预测运算符的优先级小于等于当前运算符，就把当前处理的对的右部与左侧关联，即 (a+b) binop unparsed</span></span><br><span class="line">		<span class="comment">// 如果预测运算符的优先级大于当前运算符，就把当前处理的对的右部与右侧关联，即 a+(b binop unparsed)</span></span><br><span class="line">		<span class="keyword">int</span> NextPrec= GetTokPrecedence();</span><br><span class="line">		<span class="keyword">if</span>(TokPrec &lt; NextPrec)</span><br><span class="line">		&#123;</span><br><span class="line">            RHS = ParseBinOpRHS(TokPrec+<span class="number">1</span>,<span class="built_in">std</span>::move(RHS));</span><br><span class="line">            <span class="keyword">if</span>(!RHS)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//合并 LHS/RHS</span></span><br><span class="line">		LHS = llvm::make_unique&lt;Binary&lt;ExprAST&gt;(BinOp,<span class="built_in">std</span>::move(LHS),<span class="built_in">std</span>::move(RHS));</span><br><span class="line"></span><br><span class="line"> 	 	&#125; <span class="comment">//跳转回顶部，继续执行while循环</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们知道我们<strong>主要RHS的二元运算符</strong>的优先级高于<strong>当前的二元运算符</strong>，因此我们知道任何优先于**+<strong>的</strong>对<strong>的序列应该被</strong>一起解析<strong>并被返回为</strong>RHS**。为此，就要用递归方式调用ParseBinOpRHS，指定TokPrec+1作为其继续执行的最小优先级。在上面的例子中，这会导致它将**(c+d)*e*f<strong>的AST节点作为RHS返回，最后将其设置为</strong>第二个+**的RHS。</p>
<p>最后，在下一次的while循环中，解析**+g**并将其添加到AST。</p>
<p>此时，已经可以将解析器指向任意token流并从中构建表达式，并且会停止在不属于表达式的第一个token处。</p>
<h6 id="解析函数声明-ParsePrototype">解析函数声明 / ParsePrototype</h6>
<p>目前缺少功能原型的处理，在万花筒语言中，这些用于<strong>extren</strong>函数声明以及<strong>函数体定义</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///  ::= id &#x27;(&#x27; id* &#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; <span class="title">ParsePrototype</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要输入函数名（标识符）</span></span><br><span class="line">    <span class="keyword">if</span>(CurTok!=tok_identifier)</span><br><span class="line">        <span class="keyword">return</span> LogErrorP(<span class="string">&quot;Expected function name in prototype&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用全局变量IdentifierStr保存函数名</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> FnName = IdentifierStr;</span><br><span class="line">    getNextToken();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数需要输入括号</span></span><br><span class="line">    <span class="keyword">if</span>(CurTok!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> LogErrorP(<span class="string">&quot;Expected &#x27;(&#x27; in prototype&quot;</span>);</span><br><span class="line">    <span class="comment">//读取参数名列表</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ArgNames;</span><br><span class="line">    <span class="comment">//如果下一个token是</span></span><br><span class="line">    <span class="keyword">while</span>(getNextToken() == tok_idenifier)</span><br><span class="line">        ArgNames.push_back(IdentifierStr);</span><br><span class="line">    <span class="comment">//函数需要定义</span></span><br><span class="line">    <span class="keyword">if</span>(CurTok!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    	<span class="keyword">return</span> LogErrorP(<span class="string">&quot;Expected &#x27;)&#x27; in prototype&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//完成 </span></span><br><span class="line">    getNextToken();  <span class="comment">//吃掉右括号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建函数AST</span></span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;PrototypeAST&gt;(FnName,<span class="built_in">std</span>::move(ArgsNames));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="解析函数定义-ParseDefinition">解析函数定义 / ParseDefinition</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// definition ::= &#x27;def&#x27; prototype expression</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; <span class="title">ParseDeFinition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNextToken();  <span class="comment">//吃掉def</span></span><br><span class="line">    <span class="keyword">auto</span> Proto = ParsePrototype();</span><br><span class="line">    <span class="keyword">if</span>(!Proto) <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">//如果函数声明是空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> E = ParseExpression())</span><br><span class="line">        <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto),<span class="built_in">std</span>::move(E));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，支持<strong>extern</strong>来声明<strong>sin</strong>和<strong>cos</strong>之类的函数，以及支持用户函数的向前声明，这些<strong>extern</strong>只是没有代码体的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// external ::= &#x27;extern&#x27; prototype</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; <span class="title">ParseExtern</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNextToken(); <span class="comment">//吃掉extern</span></span><br><span class="line">    <span class="keyword">return</span> ParsePrototype();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，还让用户输入任意顶级表达式并动态评估它们，将通过为它们定义匿名的nullary（零参数）函数来处理这个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// toplevelexpr ::=expression</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; <span class="title">ParseTopLevelExpr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> E = ParseExpression())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创造一个匿名函数声明</span></span><br><span class="line">        <span class="keyword">auto</span> Proto = llvm::make_unique&lt;PrototypeAST&gt;(<span class="string">&quot;&quot;</span>,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto),<span class="built_in">std</span>::move(E));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在，已经完成了所有部分。</p>
<h5 id="驱动程序">驱动程序</h5>
<p>下面的程序只是通过<strong>顶级调度循环调用所有解析的程序</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// top ::= definition | external | expression | &#x27;;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fprint(<span class="built_in">stderr</span>,<span class="string">&quot;ready&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(CurTok)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> tok_eof:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:  <span class="comment">//忽略顶级分号</span></span><br><span class="line">                getNextToken();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> tok_def:</span><br><span class="line">                HandleDefinition();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> tok_extern:</span><br><span class="line">                HandleExtern();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                HandleTopLevelExpression();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>忽略顶级分号：</p>
<p>如果在命令行中输入<strong>4+5</strong>，解析器不能确定是不是已经结尾，第一种情况，在下一行可以继续输入<strong>def foo</strong>，在这种情况下，<strong>4+5</strong>是顶级表达式的结尾；或者可以继续输入***6**，这将继续表达式的输入。使用<strong>顶级分号</strong>将允许输入<strong>4+5</strong>，这样解析器就会知道已经输入完成。</p>
</li>
</ul>
<h4 id="代码生成LLVM-IR">代码生成LLVM IR</h4>
<h5 id="代码生成设置">代码生成设置</h5>
<p>为了生成LLVM IR，需要一些简单的设置才能开始。</p>
<p>首先，要在<strong>每个AST类</strong>中定义虚拟方法<strong>codegen</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原代码见【表达式】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ExprAST() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">double</span> Val;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NumberExprAST(<span class="keyword">double</span> Val) : Val(Val) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>codegen方法表示为该AST节点<strong>发出IR及其依赖的所有内容</strong>，并且它们都返回一个<strong>LLVM Value</strong>对象，<strong>Value</strong>是用于表示LLVM中的<strong>静态单一分配（SSA）寄存器</strong>或<strong>SSA值</strong>。</p>
<p><strong>SSA值</strong>得最独特之处在于它们的值是在相关指令<strong>执行时</strong>计算的，并在指令<strong>重新执行之前</strong>不会获得新值。也就是说，<strong>没有办法改变SSA值</strong>。</p>
<p>接下来要完成像之前用于解析器的<strong>LogError</strong>的方法，它将用于报告<strong>在代码生成期间发现的错误</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LLVMContext TheContext;</span><br><span class="line"><span class="keyword">static</span> IRBuilder&lt;&gt; Builder(TheContext);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Module&gt; TheModule;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,Value *&gt; NameValues;</span><br><span class="line"></span><br><span class="line"><span class="function">Value *<span class="title">LogErrorV</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogError(Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的静态变量将在<strong>代码生成</strong>期间使用。</p>
<p><strong>TheContext</strong>是一个不透明的对象，拥有许多核心LLVM数据结构。</p>
<p><strong>Builder对象</strong>是一个辅助对象，可以生成LLVM指令。<strong>IRBuilder类</strong>模板的实例可以跟踪插入指令的<strong>当前位置</strong>，并具有创建新指令的方法。</p>
<p><strong>TheModule</strong>是一个包含函数和全局变量的LLVM构造。</p>
<p><strong>NameValues图</strong>跟踪哪些值在当前范围内，是代码的符号表。在这种形式的万花筒语言中，唯一可以引用的是<strong>功能参数</strong>。</p>
<h5 id="表达式代码生成">表达式代码生成</h5>
<p>为表达式节点生成LLVM代码</p>
<h6 id="数字文本">数字文本</h6>
<p>首先编写<strong>数字文本</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">NumberExprAST::codegen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ConstantFP::get(TheContext, APFloat(Val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在LLVM IR中，数字常量用<strong>ConstantFP类</strong>表示，它在<strong>APFloat</strong>内部保存数值（APFloat能够保持任意精度的浮点常量）。这段代码基本上只是创建并返回一个ConstantFP。</p>
<p>在LLVM IR中，常量都是<strong>唯一的</strong>并且<strong>共享</strong>，出于这个原因，API使用<strong>foo::get (…)</strong> 而不是<strong>new foo (…)<strong>或</strong>foo::Create (…)</strong>。（即不用再次创建）</p>
<h6 id="变量">变量</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">VariableExprAST::codegen</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 在函数中查找此变量</span></span><br><span class="line">  Value *V = NamedValues[Name];</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    LogErrorV(<span class="string">&quot;Unknown variable name&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在简单版的万花筒语言中，假设变量已经在某处发出并且其值可用。</p>
<p>实际上，<strong>NamedValues</strong>映射中唯一的值是函数参数，此程序只是检查指定的名称是否在映射中（如果没有，就引用未知变量）并返回其值。</p>
<h6 id="二元运算符">二元运算符</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Value *L = LHS-&gt;codegen();</span><br><span class="line">  Value *R = RHS-&gt;codegen();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">switch</span> (Op) </span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">&quot;addtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFSub(L, R, <span class="string">&quot;subtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFMul(L, R, <span class="string">&quot;multmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">    L = Builder.CreateFCmpULT(L, R, <span class="string">&quot;cmptmp&quot;</span>);</span><br><span class="line">          </span><br><span class="line">    <span class="comment">//将布尔值0/1转化为双精度值0.0/1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext),</span><br><span class="line">                                <span class="string">&quot;booltmp&quot;</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">&quot;invalid binary operator&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="函数调用">函数调用</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">CallExprAST::codegen</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在全局模块表中查找名称</span></span><br><span class="line">  Function *CalleeF = TheModule-&gt;getFunction(Callee);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!CalleeF)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">&quot;Unknown function referenced&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// If argument mismatch error.</span></span><br><span class="line">  <span class="keyword">if</span> (CalleeF-&gt;arg_size() != Args.size())</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">&quot;Incorrect # arguments passed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = Args.size(); i != e; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (!ArgsV.back())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(CalleeF, ArgsV, <span class="string">&quot;calltmp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="功能代码生成">功能代码生成</h5>
<h6 id="声明代码的生成">声明代码的生成</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">PrototypeAST::codegen</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 创建函数类型:  double(double,double) etc.</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type*&gt; <span class="title">Doubles</span><span class="params">(Args.size(),</span></span></span><br><span class="line"><span class="function"><span class="params">                             Type::getDoubleTy(TheContext))</span></span>;</span><br><span class="line">    </span><br><span class="line">  FunctionType *FT =</span><br><span class="line">    FunctionType::get(Type::getDoubleTy(TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">  Function *F =</span><br><span class="line">    Function::Create(FT, Function::ExternalLinkage, Name, TheModule);</span><br></pre></td></tr></table></figure>
<p><strong>FunctionType::get</strong>创建FunctionType，它的调用应该用于<strong>给定的Prototype</strong>。由于Kaleidoscope中的所有函数参数都是<strong>double类型</strong>，因此第一行创建了一个“N”LLVM double类型的向量。然后它使用该Functiontype::get方法创建一个函数类型，该函数类型将“N”双精度作为参数，结果返回一个double，而不是vararg（false参数表示这一点）。请注意，LLVM中的类型与常量一样是唯一的，所以你不要<strong>new</strong>一个类型，你<strong>get</strong>它。</p>
<p>上面的最后一行实际上创建了<strong>与Prototype相对应的IR功能</strong>。这表示要使用的类型，链接和名称，以及要插入的模块。<strong>外部链接</strong>意味着该功能可以在当前模块外部定义,可以由模块外部的功能调用。传入的名称是用户指定的名称：由于指定了<strong>TheModule</strong>，因此该名称在<strong>TheModule符号表</strong>中注册。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置所有参数的名称</span></span><br><span class="line"><span class="keyword">unsigned</span> Idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : F-&gt;args())</span><br><span class="line">  Arg.setName(Args[Idx++]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> F;</span><br></pre></td></tr></table></figure>
<h4 id="我只能说，再往后我就不会了">我只能说，再往后我就不会了</h4>
<p><strong>就写到这里了，以后看情况可能会再写一点</strong></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">LLVM学习记录</a></div><div class="post_share"><div class="social-share" data-image="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720210401170113-gigapixel-scale-2_00x.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="WeChat"/></a><div class="post-qr-code-desc">WeChat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/01/JavaWeb/"><img class="prev-cover" src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/8E8621BC53194CCB0AAE766629996689.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【JavaWeb】</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/28/prim%E7%AE%97%E6%B3%95/"><img class="next-cover" src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/8E8621BC53194CCB0AAE766629996689.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【数据结构01】</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">K1bo24</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kibou24"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kibou24" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1553933546@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到二十四的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E8%8A%B1%E7%AD%92%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%92%8C%E8%AF%8D%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">万花筒语言简介和词法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%87%E8%8A%B1%E7%AD%92%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">万花筒语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8-gettok"><span class="toc-number">1.2.</span> <span class="toc-text">词法分析器 &#x2F; gettok</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%88AST%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">抽象语法树（AST）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F-ExprAST-NumberExprAST"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">表达式 &#x2F; ExprAST &#x2F; NumberExprAST</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8FAST-VariableExprAST"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">变量表达式AST &#x2F; VariableExprAST</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8FAST-BinaryExprAST"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">二元运算符表达式AST &#x2F; BinaryExprAST</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8FAST-CallExprAST"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">函数调用表达式AST &#x2F; CallExprAST</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8EAST-PrototypeAST"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">函数声明AST &#x2F; PrototypeAST</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89AST-FunctionAST"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">函数定义AST &#x2F; FunctionAST</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.2.</span> <span class="toc-text">解析基础</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA-getNextToken"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">缓冲区 &#x2F; getNextToken</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%B8%AE%E5%8A%A9-LogError"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">错误帮助 &#x2F; LogError</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">基本表达式的解析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90-ParseNumberExpr"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">数字表达式的解析 &#x2F; ParseNumberExpr</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%A7%A3%E6%9E%90-ParseParenExpr"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">括号运算符的解析 &#x2F; ParseParenExpr</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90-ParseIdentifierExpr"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">标识符表达式的解析 &#x2F; ParseIdentifierExpr</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90-ParsePrimary"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">主表达式的解析 &#x2F; ParsePrimary</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">二元表达式的解析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8-GetTokPrecedence"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">优先级表 &#x2F; GetTokPrecedence</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E5%BC%8F-ParseExpression"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">解析表达式 &#x2F; ParseExpression</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E4%BA%8C%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%B3%E9%83%A8-ParseBinOpRHS"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">解析二元表达式的右部 &#x2F; ParseBinOpRHS</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E-ParsePrototype"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">解析函数声明 &#x2F; ParsePrototype</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-ParseDefinition"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">解析函数定义 &#x2F; ParseDefinition</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.5.</span> <span class="toc-text">驱动程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90LLVM-IR"><span class="toc-number">1.4.</span> <span class="toc-text">代码生成LLVM IR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.4.1.</span> <span class="toc-text">代码生成设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.4.2.</span> <span class="toc-text">表达式代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%96%87%E6%9C%AC"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">数字文本</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">二元运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">函数调用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.4.3.</span> <span class="toc-text">功能代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">声明代码的生成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E5%8F%AA%E8%83%BD%E8%AF%B4%EF%BC%8C%E5%86%8D%E5%BE%80%E5%90%8E%E6%88%91%E5%B0%B1%E4%B8%8D%E4%BC%9A%E4%BA%86"><span class="toc-number">1.5.</span> <span class="toc-text">我只能说，再往后我就不会了</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/JavaWeb/" title="【JavaWeb】"><img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/8E8621BC53194CCB0AAE766629996689.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【JavaWeb】"/></a><div class="content"><a class="title" href="/2022/03/01/JavaWeb/" title="【JavaWeb】">【JavaWeb】</a><time datetime="2022-03-01T08:36:54.101Z" title="发表于 2022-03-01 16:36:54">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/08/The%20Kaleidoscope%20Language/" title="The Kaleidoscope Language（万花筒语言）——LLVM学习"><img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720210401170113-gigapixel-scale-2_00x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The Kaleidoscope Language（万花筒语言）——LLVM学习"/></a><div class="content"><a class="title" href="/2022/01/08/The%20Kaleidoscope%20Language/" title="The Kaleidoscope Language（万花筒语言）——LLVM学习">The Kaleidoscope Language（万花筒语言）——LLVM学习</a><time datetime="2022-01-08T11:48:12.519Z" title="发表于 2022-01-08 19:48:12">2022-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/28/prim%E7%AE%97%E6%B3%95/" title="【数据结构01】"><img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/8E8621BC53194CCB0AAE766629996689.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构01】"/></a><div class="content"><a class="title" href="/2021/11/28/prim%E7%AE%97%E6%B3%95/" title="【数据结构01】">【数据结构01】</a><time datetime="2021-11-28T02:08:15.319Z" title="发表于 2021-11-28 10:08:15">2021-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/27/W-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程"><img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/20211127150347.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java多线程"/></a><div class="content"><a class="title" href="/2021/11/27/W-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程">Java多线程</a><time datetime="2021-11-27T06:50:30.135Z" title="发表于 2021-11-27 14:50:30">2021-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/15/MySQL07-Insert%E8%AF%AD%E5%8F%A5%E8%AF%A6%E8%A7%A3/" title="初识MySQL07 ☆ 插入修改和删除语句详解"><img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/1584375580100.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="初识MySQL07 ☆ 插入修改和删除语句详解"/></a><div class="content"><a class="title" href="/2021/04/15/MySQL07-Insert%E8%AF%AD%E5%8F%A5%E8%AF%A6%E8%A7%A3/" title="初识MySQL07 ☆ 插入修改和删除语句详解">初识MySQL07 ☆ 插入修改和删除语句详解</a><time datetime="2021-04-15T11:25:57.984Z" title="发表于 2021-04-15 19:25:57">2021-04-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720210401170113-gigapixel-scale-2_00x.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By K1bo24</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to 24's blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>